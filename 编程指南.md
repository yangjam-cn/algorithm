<!--
 * @Copyright: 《高质量c++/c编程指南》
 * @File name: 编程指南.md
 * @Description: 
 * @Author: yangjam
 * @Version: demo
 * @Date: 2020-06-27 09:49:59
 * @History:
   * 2020.6.27--增加编码规范
 * @LastEditTime: 2020-06-28 16:47:52
--> 
<!-- TOC -->

- [文件结构](#文件结构)
  - [版权和版本声明](#版权和版本声明)
  - [头文件结构](#头文件结构)
  - [定义文件的结构](#定义文件的结构)
  - [头文件的作用](#头文件的作用)
  - [目录结构](#目录结构)
- [程序的版式](#程序的版式)
  - [空行](#空行)
  - [代码行](#代码行)
  - [代码行内空格](#代码行内空格)
  - [对齐](#对齐)
  - [长行拆分](#长行拆分)
  - [修饰符的位置](#修饰符的位置)
  - [注释](#注释)
  - [类的版式](#类的版式)
- [命名规则](#命名规则)
  - [共性规则](#共性规则)
  - [简单的windows应用程序命名规则](#简单的windows应用程序命名规则)
  - [简单的unix应用程序命名规则](#简单的unix应用程序命名规则)
- [表达式和基本语句](#表达式和基本语句)
  - [运算符的优先级](#运算符的优先级)
  - [复合表达式](#复合表达式)
  - [if语句](#if语句)
    - [布尔变量与零值比较](#布尔变量与零值比较)
    - [整形变量与零值比较](#整形变量与零值比较)
    - [浮点变量与零值比较](#浮点变量与零值比较)
  - [循环语句的效率](#循环语句的效率)
  - [for语句的循环控制变量](#for语句的循环控制变量)
  - [switch语句](#switch语句)
- [常量](#常量)
  - [为什么需要常量](#为什么需要常量)
  - [const和#define的比较](#const和define的比较)
  - [常量定义规则](#常量定义规则)
  - [类中的常量](#类中的常量)
  - [* 类常量应该使用类中的枚举常量来实现](#ulli类常量应该使用类中的枚举常量来实现liul)
- [函数设计](#函数设计)
  - [参数的规则](#参数的规则)
  - [返回值的规则](#返回值的规则)
  - [函数内部实现规则](#函数内部实现规则)
  - [其它建议](#其它建议)
  - [使用断言](#使用断言)
  - [引用与指针的比较](#引用与指针的比较)

<!-- /TOC -->

------------
# 文件结构
## 版权和版本声明
* 版权和版本声明位与头文件和定义文件的开头，主要内容有：
  1. 版本信息
  2. 文件名称，标识符，摘要
  3. 当前版本号，作者/修改者，完成日期
  4. 版本历史信息  
    ![avatar](/picture/版权和版本声明.png)
## 头文件结构
* 头文件由三部分内容组成
  1. 开头处的版本和版权声明
  2. 预处理块
  3. 函数和类结构声明
* 规则
  1. 为了防止头文件被重复引用，应使用ifndef/define/endif结构产生预编译块
  2. 用#include < filename.h >来引用标准库的头文件（编译器将从标准库目录开始搜索）
  3. 用#include "filename.h"来引用非标准库的头文件（编译器将从工作目录开始搜索）
  * 建议
    1. 头文件只放“声明”不放“定义”
    2. 不提倡使用全局变量，尽量不要在头文件中出现extern int value这类声明
    ![avatar](/picture/头文件结构.png)
## 定义文件的结构
* 定义文件由三部分内容
  1. 定义文件开头处的版权和版本声明
  2. 对头文件的引用
  3. 程序的实现体(包括数据和代码)
## 头文件的作用
* 通过头文件来调用库功能
* 加强类型安全检查
## 目录结构
* 如果一个软件的头文件数目较多，通常应将头文件和定义文件分别保存于不同的目录

--------------------
# 程序的版式
## 空行
* 规则
  1. 在每个类声明、每个函数定义结束之后都要加空行
  2. 在一个函数体内，逻辑上密切相关的语句之间不加空行，其它地方应加空行分隔
## 代码行
* 规则
  1. 一行代码只做一件事，如只定义一个变量，或只写一条语句
  2. if、for、while、do等语句各自占一行，执行语句不得紧跟其后。无论执行语句有多少都加{}
  * 建议
    1. 尽可能在定义变量的同时初始化该变量
## 代码行内空格
* 规则
  1. 关键字之后要留空格。像if、for、while等关键字之后应留一个空格在接“(”，以突出关键字
  2. 函数名之后不要留空格，紧跟“(”以与关键字区别
  3. “(”向后紧跟，“)”、“,”、“;”向前紧跟，紧跟处不留空格
  4. “,”之后要留空格，如果";"不是一行结束其后要留空格
  5. 赋值运算符、比较操作符、算数操作符、逻辑操作符、位域操作符等二元操作符的前后应当加空格
  6. 一元操作符等前后不加空格
  7. 像“[]”、“.”、“->”等操作符前后不加空格
  * 建议
    1. 对于较长的for和if语句，为了紧凑可以适当去掉部分空格
## 对齐
* 规则
  1. 程序的分节符"{"和"}"应独占一行并且位于同一列，同时与引用他们的语句左对齐
  2. {}之内的代码块在"{"右边数据处左对齐
## 长行拆分
* 规则
  1. 代码行最大长度宜控制在70~80个字符内
  2. 长表达式要在低优先级操作符除拆分成新行，操作符放在新行之首，拆分的新行要进行适当的缩排，使排版整齐
## 修饰符的位置
* 规则
  1. 应当将修饰符 * 和 & 紧靠变量名
## 注释
* 规则
  1. 注释是对代码的“提示”，而不是文档
  2. 代码本来就很清楚，不用加注释
  3. 边写代码遍写注释，修改代码同时修改注释
  4. 注释应当准确、易懂、防止注释的二义性
  5. 尽量避免在注释中使用缩写
  6. 注释的位置应与被描述的代码紧邻，可以放在代码的右方或上方，不可放在下方
  7. 当代码较长，特别是有多重嵌套时，应当在部分段落结束时加注释
   ![avatar](/picture/程序注释.png)
## 类的版式
* 建议使用"以行为中心"的书写方式
    ![avatar](/picture/类的版式.png)

----------------
# 命名规则
## 共性规则
* 规则
  1. 标识符应当直观且可以拼读，可望文知意
  2. 标识符长度应该符合"min-length && max-information"原则
  3. 命名规则尽量与所使用的操作系统或开发工具一致。windows通常使用“大小写”混排的方式，unix通常使用“小写加下划线”的方式
  4. 程序中不要出现仅靠大小写区分的标识符
  5. 程序中不要出现标识符完全相同的局部变量和全局变量
  6. 变量的名字应当使用“名词”或者“形容词+名词”
  7. 全局函数的名字应当使用“动词”或者“动词+名词”，类的成员函数应当只使用“动词”
  8. 用正确的反义词组命名具有互斥意义的变量或相反动作的函数
  * 建议
    1. 尽量避免名字中出现数字编号，除非逻辑上的确需要编号
## 简单的windows应用程序命名规则
* 类名和函数名用大写字母开头的单词组合而成
* 变量和参数用小写字母开头的单词组合而成
* 常量全用大写的字母，用下划线分割单词
* 静态变量前加前缀s_
* 如果不得已需要全局变量，则使用全局变量加前缀g_
* 类的数据成员加前缀m_
* 为了防止某一软件库中的某一些标识和其它软件库中的冲突，可以为各种标识符加上能反映软件性质的前缀
## 简单的unix应用程序命名规则

--------------------------
# 表达式和基本语句
## 运算符的优先级
* 见c/数据结构.md  
  ![](/picture/运算符优先级.png "运算符优先级")
* 规则
  1. 如果代码中的运算符比较多，用括号确定表达式的操作顺序，避免使用默认优先级
## 复合表达式
* 规则
  1. 不要编写太复杂的复合表达式
  2. 不要有多用途的符和表达式
  3. 不要混淆符和表达式与“真正的数学表达式”
## if语句
### 布尔变量与零值比较
* `不可将布尔变量直接与TRUE、FALSE或者1、0进行比较`  
  根据布尔类型的语义，零值为“假”，任何非零值都是“真”。TRUE的值究竟是什么并没有统一的标准。例如Visual C++将TRUE定义为1，而Visual Basic则将TRUE定义为-1。
  ```c
  /* 标准的if语句 */
  if (flag)
  if (!flag)
  ```

### 整形变量与零值比较
* `应当将整形变量用"=="或"!="直接与0比较`
  ```c
  /* 标准语句 */
  if (value == 0)
  if (value != 0)
  ```
### 浮点变量与零值比较
* `不可将浮点变量用"=="或"!="与任何数字比较`  
  无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量用"=="或"!="与数字比较，应该设法转化成">="或"<="形式。
  ```c
  /* 标准语句 */
  if ((x >= -EPSINON) && (x <= EPSINON))
  ```
## 循环语句的效率
* 建议
  1. 在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少cpu跨切循环层的次数  
  ```c
  /* 低效率 */
  for (row = 0; row < 100; row++)
  {
    for (col = 0; col < 5; col++)
    {
      sum += a[row][col];
    }
  }
  /* 高效率 */
  for (col = 0; col < 5; col++)
  {
    for (row = 0; row < 100; row++)
    {
      sum += a[row][col];
    }
  }
  ```
  2. 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断转移到循环体的外面  
  ```c
  for (i = 0; i < n; i++)
  {
    if (condition)
    {
      do_something();
    }
    else
    {
      do_otherthing();
    }
  }
  /*
   * 上面代码比下面代码多执行了n-1次逻辑判断，并且上者老要进行逻辑判断，打断了循环“流水线”作业，使得编译器不能对循环进行优化处理，降低了效率。如果n非常大，最好采用下面的写法，可以提高效率；如果n非常小，两者效率差别不明显，则采用下面写法较好。
   */
  if (condition)
  {
    for (i = 0; i < n; i++)
    {
      do_something();
    }
  }
  else
  {
    for (i = 0; i < n; i++)
    {
      do_otherthing();
    }
  }
  ```
## for语句的循环控制变量
* 不可在for循环体内修改循环变量，防止for循环失去控制
* 建议for语句的循环控制变量的取值采取“半开半闭区间写法”
  ```c
  /* 0 <= x < n, 半开半闭区间*/
  for (int x = 0; x < n; x++)
  {

  }
  /* 0 <= x <= n-1 */
  for (int x = 0; x < n - 1; x++)
  {

  }
  ```
## switch语句
* 每个case语句的结尾不要忘了加break，否则将导致多个分支重叠(除非有意为之)
* 不要忘记最后的default分支
  ```c
  switch (variable)
  {
    case value1:
      break;
    case value2:
      break;
    default:
      break;
  }
  ```
--------------------------
# 常量
## 为什么需要常量
* 改善程序的可读性
* 防止重复使用相同数字或字符串过程中发生书写错误
* 方便修改
* 规则
  1. 尽量使用含义直观的常量来表示在程序中多次出现的数字或字符串
## const和#define的比较
* const相较于#define的优点
  1. const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，并且在字符替换可能会发生意料不到的错误
  2. 部分集成的调试工具可以对const常量进行调试
* 规则
  1. 在c++程序中只使用const常量而不使用宏常量
## 常量定义规则
* 规则
  1. 需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件头部。为了方便管理，可以把不同模块的常量集中存放在一个公共的头文件中
  2. 如果一个常量与其它常量密切相关，应在定义中包含这种关系，而不应该给出一些孤立的值
## 类中的常量
* const数据成员的初始化只能在类的构造函数的初始化表中进行
* 类常量应该使用类中的枚举常量来实现
-------------------------
# 函数设计
## 参数的规则
* 规则
  1. 参数的书写要完整，不要贪图省事而只写参数的类型而省略参数的名字。如果函数没有参数，则用void填充
  2. 参数命名要恰当，顺序要合理
    * 一般应将目的参数放在前面，源参数写在后面
  3. 如果参数是指针，且仅作输入用，则应在类型前加const，以防止该指针在函数体内被意外修改
  4. 如果输入参数以值传递的方式传递对象，则宜改用"const &"方式来传递，这样可以省去临时对象的构造和析构过程，从而提高效率
* 建议
  1. 避免函数有太多参数，参数尽量控制在5个以内
  2. 尽量不要使用类型和数目不确定的参数
## 返回值的规则
* 规则
  1. 不要省略返回值的类型
  2. 函数名字与返回值的类型在语义上不可冲突
  3. 不要将正常值和错误标志混在一起返回。正常值用输出参数获得，而错误标志用return返回
* 建议
  1. 有时候函数原本不需要返回值，但是为了增加灵活性如支持链式表达，可以符加返回值
  ```c
  char *strcpy(char *strDest, const *strSrc);
  /* strcpy函数将strSrc拷贝至参数strDest中，同时函数返回值又是strDest */
  char str[20];
  int length = strlen(strcpy(str, "Hello World"));
  ```
  2. 如果函数的返回值是一个对象，有些场合用"引用传递"替换"值传递"可以提高效率。而部分场合只能使用"值传递"而不能使用"引用传递"
  ```c++
  class String
  {
      /* 赋值函数 */
      String & operate=(const String &other);
      /* 相加函数，如果没有friend修饰符则只许有一个右侧参数 */
      friend String operate+(const String &s1, const String &s2);
    private:
      char *m_data;
  }
  String & String::operate=(const String &other)
  {
    if (this == &other)
    {
      return *this;
    }
    delete m_data;

    m_data = new char[strlen(other.m_data) + 1];
    strcpy(m_data, other.m_data);
    return *this;    /* 返回的是*this的引用，无需拷贝过程 */
  }
  /*
   * 对于赋值函数，应当使用“引用传递”的方式返回String对象。如果用值传递的方式，虽然功能仍然正确，但是return语句要把*this拷贝到保存返回值得外部存储单元中，增加了不必要得开销
   */
   String operate+(const String &s1, const String &s2)
   {
     String temp;
     delete temp.m_data;
     temp.m_data = new char[strlen(s1.m_data) + strlen(s2.m_data) + 1];
     strcpy(temp.m_data, s1.m_data);
     strcat(temp.m_data, s2.m_data);
     return temp;
   }
   /* 
    * 应当使用“值传递”得方式返回String对象。如果改用“引用传递”，那么函数返回值是一个指向局部对象temo的"引用"。由于temp在函数结束时被自动销毁，将导致返回的"引用"无效。
    */
  ```
## 函数内部实现规则
* 规则
  1. 在函数体的"入口处"，对参数的有效性进行检查
  2. 在函数体的"出口处"，对return语句的正确性和效率进行检查
     1. return语句不可返回指向“栈内存”的“指针”或者"引用"，因为该内存在函数体结束时被自动销毁
     2. 要搞清楚返回的究竟是"值"、"指针"还是"引用"
     3. 如果函数返回值是一个对象，要考虑return语句的效率
      ```c++
      return String(s1 + s2);
      /*
       * 编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的花费
       */
      String temp(s1 + s2);
      return temp;
      /*
       * temp对象被创建，同时完成初始化，然后拷贝构造函数把temp拷贝到保存返回值的外部存储单元中，最后，temp在函数结束时被销毁(调用析构函数)
       */
      ```
## 其它建议
1. 函数的功能要单一，不要设计多用途的函数
2. 函数体的规模要小，尽量控制在50行代码之内
3. 尽量避免函数带有“记忆”功能，相同的输入应当产生相同的输出
4. 不仅要检测输入参数的有效性，还要检查通过其它途径进入函数体内的变量的有效性，例如全局全量、文件句柄等
5. 用于出错处理的返回值一定要清楚，让使用者不容易忽视或误解错误情况
## 使用断言
* 程序一般分为debug和release版本，debug版本用于内部调试，release版本发行给用户使用
* 断言assert是仅在debug版本起作用的宏，用于检查“不应该”发生的情况。在运行过程中，如果assert的参数为假，那么程序就会中止(一般还会出现提示对话，说明在什么地方引发了assert)
  ```c
  void *memcpy(void *pvTo, const void *pvFrom, size_t size)
  {
    assert((pvTo != NULL) && (pvFrom != NULL));    /* 使用断言 */
    byte *pbTo = (byte *)pvTo;    /* 防止改变pvTo的地址 */
    byte *pbFrom = (byte *)pvFrom;    /* 防止改变pvFrom的地址 */
    while (size-- > 0)
    {
      *pbTo++ = *pbFrom++；
    }
    return pvTo;
  }
  ```
* 规则
  1. 使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且一定要做出处理的
  2. 在函数的入口处，使用断言检查参数的合法性
* 建议
  1. 在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”，一旦确定了假定，就要使用断言进行检查
  2. 一般教科书都鼓励进行放错设计，但要记住这种编程风格可能会隐藏错误。当进行防错设计时，如果“不可能发生”的事情的确发生了，则要使用断言进行报警
## 引用与指针的比较
* 引用的规则
  1. 引用被创建的同时必须被初始化(指针则可以在任何时候被初始化)
  2. 不能有NULL引用，引用必须与合法的存储单元关联(指针则可以时NULL)
  3. 一旦引用被初始化，就不能改变引用的关系(指针则可以随时改变所指对象)