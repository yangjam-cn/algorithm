<!--
 * @Copyright: https://github.com/yangjam-cn/algorithm
 * @File name: 文件名
 * @Description:    
 * @Author: yangjam
 * @Version: 1.0
 * @Date: 2020-08-15 15:10:20
 * @History: 修改历史列表，每条修改记录应包括修改日期、修改者及修改内容简述
 * @LastEditTime: 2020-08-28 19:19:08
-->
# 文件系统
* / 根目录
  * bin  存放用户命令
  * sbin  管理员命令
  * boot  linux启动文件
  * dev  设备文件
  * etc  配置文件
  * lib   必要的链接库
  * proc 该目录的数据都在内存中
## i结点
* 创建文件后，会同时创建一个`i节点`和一个“块”，i节点存放文件的属性信息，并存放所对应数据所在块
的地址的指针；“块”存放文件的真正数据，每个块最多存放一个文件，而当一个块存放不下时，占用下一个块

# 进程
* 程序时进程的组成部分之一，进程的运行目标时执行它对应的程序
* 进程是动态概念，是程序的执行过程；程序是静态概念，是指令的有序集合
* 进程具有并行性的特征
  * 独立性：进程是一个相对完整的资源分配单位
  * 异步性：每个进程按照各自独立的、不可预知的速度向前推进
## 进程的描述
* 进程控制块(Process Control Block, PCB)
* 有关的程序段
* 操作的数据集
### 进程的标识符
* 进程标识符(Process Identification, PID)，在64位系统中为32位无符号整数(pid_t)
* 每个进程都有唯一的pid，内核通过pid识别不同的进程，同时pid也是内核提供给用户程序的接口
* pid存放在进程描述符的PID域中，被顺序编号，新创建的pid通常是前一个进程的pid加1
* 为了与16位unix兼容，linux允许的最大pid为32767，当linux内核创建第32767个进程时，就必须重新使用闲置的pid号
### pid文件
* /var/run目录下*.pid，记录进程的pid号，防止进程启动多个副本，只有获得相应的pid文件写入权限的的进程才能正常启动，并把自身的pid号写入该文件中
* 文件加锁法，进程运行后给.pid文件加一个文件锁，只有获得该锁的进程才有写入权限(F_WRLCK)，其它试图获得该锁的进程会自动退出。给文件加锁的函数为fcntl()，如果成功锁定，进程则继续往下执行，锁定不成功，则说明有同样进程在执行，进程退出。
* pid读写法，先启动的进程往pid文件中写入自己的pid号，然后其它进程判断该pid文件中是否有数据
  
## 进程调度
* 先来先去服务法(FCFS)，将进程按变为就绪状态的先后次序排成队列，并按照先来先服务的方式进行调度
* 时间片轮转法(RR)，将cpu的处理时间划分成一个个时间片，就绪状态的各个进程轮流运行一个时间片，当时间片结束时，就强迫运行进程让出时间片，该进程进入就绪队列等待下一次调度
* 优先级算法，进程调度每次将处理机分配给具有最高优先级的就绪进程
* 多级反馈队列法
  * 系统按优先级级别不同设置若干个就绪队列，除最低一级的队列采用RR外，其它各级队列采用FCFS
  * 系统总是先调度该级别队列中的进程，仅当该队列为空时才去调度下一级队列中的进程
  * 当执行进程使用完其时间片时间，便被剥夺并进入下一级就绪队列
  * 当等待进程被唤醒时，进入与其优先级对应的就绪队列，若其优先级高于当前执行进程，便抢占cpu去执行
### linux调度策略
* 静态优先级，只针对实时进程，由用户赋给实时进程，范围为1~99，以后调度程序不再改变
* 动态优先级，只应用于普通进程，实质是基本时间片与当前时期内剩余时间片之和
* 实时进程的静态优先级总是高于普通进程的动态优先级，只有处于可运行状态的进程中且没有实时进程后，调度程序才开始运行普通进程
* linux实时进程调度策略
  * SCHED_FIFO，当调度程序将cpu分配给一个进程时，该进程的task_struct保留在运行队列的当前位置，如果没有更高优先级的实时进程，这个进程可以占用cpu直到运行结束
  * SCHED_RR，当调度程序将cpu分配给一个进程时，该进程的task_struct放置到运行队列的末尾，确保把cpu时间公平分配给具有相同优先级的进程
### 进程状态
1. 可运行状态(TASK_RUNNING)
   * 该状态的进程，要么正在cpu上运行(当前进程)，要么准备运行(等待cpu资源)，系统中有一个运行队列，容纳处于该状态的进程
2. 可中断的等待状态(TASK_INTERRUPTIBLE)
   * 进程被挂起，直到条件(可能包括，产生一个硬件中断、释放进程正等待的系统资源或者传递一个信号)满足，唤醒进程返回task_running状态
3. 不可中断的等待状态(TASK_UNINTERRUPTIBLE)
   * 与上一状态相似，但是传递信号给睡眠的进程不能改变其状态，
4. 暂停状态(TASK_STOPPED)
   * 进程的执行被暂停，当进程收到SIGSTOP,SIGTSTP,SIGTTIN,SIGTT0U信号后进入暂停状态
5. 僵死状态(TASK_ZOMBIE)
   * 进程的执行已经终止，但是父进程还没有发布wait类似系统调用来返回有关终止进程的信息。在父进程发布此类系统调用前，内核不能丢弃包含在终止进程task_struct结构中的数据，因为父进程可能还需要这些信息
## 进程分类
* 前台进程，普通进程即需要和用户交换的进程，默认情况下，启动的进程都是在前台运行，此时该进程占据shell，无法进行其它操作直到该进程结束
* 后台进程，不需要交互的进程，在启动时加一个"&"，该进程将在后台运行，不占据shell，但关闭shell时，后台进程也随着一起退出
### 守护进程
* 守护进程(Daemon Process)时运行在后台的一种特殊进程
* 守护进程脱离终端运行，不被终端的信息打断，执行过程也不在终端显示
* 守护进程一般在系统启动时运行，除非强行终止，直到系统关机都保持运行‘
* 守护进程经常以root权限运行，因为需要使用特殊端口(1~1024)或访问某些特殊资源
* 守护进程的父进程时init进程，它真正的父进程创建出子进程后就先于子进程退出，因此它是由init继承的孤儿进程
* 守护进程通常以d结尾
#### 守护进程的特点
* 后台运行
* 与运行前的环境隔离开
* 启动方式
  * 从启动脚本/etc/rc.d中启动
  * 利用xinet超级服务器启动
  * 由crond定时启动，在终端用nohup启动也是守护进程
* 具有root权限
* 父进程为init进程
* 不用控制终端，其TTY列以“？”表示，TPGID为-1
* 守护进程都是各自进程组合会话过程的唯一进程
#### 守护进程分类
* 独立启动(stand_alone)守护进程
   * 随系统启动，启动后常驻内存，会一直占用系统资源，当外界由要求时响应速度块，通常在/etc/rc.d/init.d目录下
* 超级守护进程
  * 系统启动时，由一个统一的守护进程xinet来负责管理一些进程，当相应请求时，需要通过xinet的转接才可以唤醒被xinet管理的进程，只有xinet一直占用系统资源 
* 每个守护进程监视一个端口，端口信心可通过/etc/services查看
* 每个守护进程都会有一个脚本，可理解为工作配置文件，守护进程的脚本需要放在指定位置，
  * 独立守护进程的脚本呢放在/etc/init.d/目录下，也包括xinet的shell脚本
  * 超级守护进程按照xinet中脚本指示，所管理的进程位于/etc/xinetd.config目录下


# 线程
## 多线程的优势
* 软件拥有灵敏的响应  软件中存在多个任务时，多个任务由不同现程去执行，不同线程各自占用一段cpu时间，即使线程任务还没完成，也会让出cpu时间给其它线程有机会执行
* 充分利用多核处理器  多个线程运行在不同的cpu核上，增加效率
* 更高效通信  同一进程的线程，共享该进程的地址空间，可以访问相同的数据
* 开销比进程小  创建线程时不需要分配内存空间等资源，创建时间更短


# http
## http请求过程
* 客户端发起三次握手与服务器建立连接
* 客户端发起http请求
* 客户端发送http请求报文首部，如果是post操作还会包含http报文主体部分
* http服务器响应客户端请求
* http服务器发送响应报文首部和主体部分
* 关闭连接