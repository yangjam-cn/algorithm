<!--
 * @Copyright: 《数据结构--C语言描述》陈慧南 编著，《C Primer Plus》
 * @File name: 数据结构.md
 * @Description: 知识点整理和梳理
 * @Author: yangjam
 * @Version: 
 * @Date: 2020-06-12 10:24:50
 * @History: 
    * 6.12 整理数据类型的基本概念
 * @LastEditTime: 2020-07-13 14:42:47
--> 
<!-- TOC -->

- [概论](#概论)
  - [1.1 什么是数据结构](#11-什么是数据结构)
    - [1.1.1 基本概念](#111-基本概念)
    - [1.1.2 数据的逻辑结构](#112-数据的逻辑结构)
    - [1.1.3 数据的存储结构](#113-数据的存储结构)
    - [1.1.4 数据结构的运算](#114-数据结构的运算)
  - [1.2 数据抽象和抽象数据类型](#12-数据抽象和抽象数据类型)
    - [1.2.1 抽象、数据抽象和过程抽象](#121-抽象数据抽象和过程抽象)
    - [1.2.2 封装与信息隐藏](#122-封装与信息隐藏)
    - [1.2.3 数据类型和抽象数据类型](#123-数据类型和抽象数据类型)
    - [1.2.4 数据结构和抽象数据类型](#124-数据结构和抽象数据类型)
  - [1.3 描述数据结构](#13-描述数据结构)
    - [1.3.1 数据结构的规范](#131-数据结构的规范)
    - [1.3.2 实现数据结构](#132-实现数据结构)
  - [算法和算法分析](#算法和算法分析)
    - [1.4.1 算法及其性能分析](#141-算法及其性能分析)
    - [1.4.2 算法的时间复杂度](#142-算法的时间复杂度)
    - [1.4.3 渐进时间复杂度](#143-渐进时间复杂度)
    - [1.4.4 最好、最坏和平均时间复杂度](#144-最好最坏和平均时间复杂度)
    - [1.4.5 算法的空间复杂度](#145-算法的空间复杂度)
- [数组和链表](#数组和链表)
  - [2.1 结构和联合](#21-结构和联合)
    - [2.1.1 结构](#211-结构)
    - [2.1.2 联合](#212-联合)
  - [2.2 数组](#22-数组)
    - [2.2.1 一维数组](#221-一维数组)
    - [2.2.2 二维数组](#222-二维数组)
    - [2.2.3 多维数组](#223-多维数组)
  - [2.3 链表](#23-链表)
    - [2.3.1 指针](#231-指针)
    - [2.3.2 单链表](#232-单链表)
    - [2.3.3 带表头结点的单链表](#233-带表头结点的单链表)
    - [2.3.4 循环链表](#234-循环链表)
    - [2.3.5 双向链表](#235-双向链表)
- [堆栈和队列](#堆栈和队列)
  - [3.1 堆栈](#31-堆栈)
    - [3.1.1 堆栈ADT](#311-堆栈adt)
    - [3.1.2 堆栈的顺序表示](#312-堆栈的顺序表示)
    - [3.1.3 堆栈的链接表示](#313-堆栈的链接表示)
  - [3.2 队列](#32-队列)
    - [3.2.1 队列ADT](#321-队列adt)
    - [3.2.2 队列的顺序表示](#322-队列的顺序表示)
    - [3.2.3 队列的链接表示](#323-队列的链接表示)
  - [3.3 表达式的计算](#33-表达式的计算)
    - [3.3.1 表达式](#331-表达式)
    - [3.3.2 中缀表达式转换为后缀表达式](#332-中缀表达式转换为后缀表达式)
- [线性表和数组ADT](#线性表和数组adt)
  - [4.1 线性表](#41-线性表)
    - [4.1.1 线性表ADT](#411-线性表adt)
    - [4.1.2 线性表的顺序表示](#412-线性表的顺序表示)
    - [4.1.3 线性表的链接表示](#413-线性表的链接表示)
    - [4.1.4 两种存储方式的比较](#414-两种存储方式的比较)
  - [4.2 多项式的数据运算](#42-多项式的数据运算)
  - [4.3 数组作为抽象数据类型](#43-数组作为抽象数据类型)
  - [4.4 特殊矩阵](#44-特殊矩阵)
- [字符串与广义表](#字符串与广义表)
  - [5.1 字符串](#51-字符串)
    - [5.1.1 字符串ADT](#511-字符串adt)
    - [5.1.2 字符串的存储表示](#512-字符串的存储表示)
- [树](#树)
  - [6.1 树的基本概念](#61-树的基本概念)
    - [6.1.1 树的定义](#611-树的定义)

<!-- /TOC -->
# 概论
## 1.1 什么是数据结构
### 1.1.1 基本概念
* `数据`：计算机加工处理的对象
    * `数值数据`：整数、实数或复数等
    * `非数值数据`：包括字符、文字、图形、图像、语音等
* `数据元素(data element)`：组成数据的成分数据
* `数据项(data item)`：组成数据元素的成分
* 一个`数据结构(data structure)`是由数据元素依据某种逻辑联系组织起来;对数据元素间的逻辑关系的描述称为数据的`逻辑结构(logic structure)`;数据的`存储结构(storage structure)`是数据结构的实现形式，是在计算机内部的表示;一个数据结构同时也包含在该类数据上执行的`运算(operation)`。
### 1.1.2 数据的逻辑结构
* 大致可分为两类`线性结构(linear structure)`和`非线性结构(non-linear structure)`
    * `集合结构(set)`：元素间的次序是随意的，元素间除了“属于同一个集合”的联系外没有其它联系
    * `线性结构(linear)`：数据元素的有序序列,数据元素间形成一对一关系
    * `树形结构(tree)`：除了一个称为`根`的特殊元素没有前驱(predecesor)只有后继(successor)外，其它元素有且仅有一个前驱，但后继不限。对于非根元素，都存在一条从根到该元素的`路径`。树中元素之间存在一对多的关系。树是层次数据结构。
    * `图状数据(graph)`：数据元素间存在多对多的关系。
### 1.1.3 数据的存储结构
* 两种基本的存储结构，`顺序(sequential)结构`和`链接(linked)结构`
    * 顺序表示方法需要使用一块连续的存储空间，并把逻辑上相关的数据元素依次存储在连续的存储区中
    * 链接表示方法，使用`节点(node)`存储元素本身信息外，还存放与该元素相关的其它元素的位置信息
### 1.1.4 数据结构的运算
* 数据结构常见运算
    1. 创建运算--创建一个数据结构
    2. 清除运算--删除数据结构中的全部元素
    3. 插入运算--在数据结构中插入一个新元素
    4. 删除运算--将数据结构中的某个指定元素删除
    5. 搜索运算--在数据结构中搜索满足一定条件的元素
    6. 更新运算--修改数据结构中某个指定元素的值
    7. 访问运算--访问数据结构中某个元素
    8. 遍历运算--按照某种次序，系统地访问数据结构的各元素
* 若一个数据结构一旦创建，其结构不会发生改变，则称为`静态数据结构(static data structure)`，否则称为`动态数据结构(dynamic data structure)`
## 1.2 数据抽象和抽象数据类型
### 1.2.1 抽象、数据抽象和过程抽象
* `抽象(abstraction)`实质是抽取共同的和本质的内容，忽略非本质的细节
* `数据抽象(data abstraction)`将数据元素间的逻辑关系和数据在计算机内的具体表示分开考虑
* `过程抽象(procedual abstraction)`将运算的定义与实现运算的具体方法分开考虑
### 1.2.2 封装与信息隐藏
* `封装(encapsulation)`是指把数据和操纵数据的运算组合在一起的机制。使用者只通过一组允许的运算访问其中的数据，而不需要了解数据的组织、存储和运算算法如何.封装对使用者隐藏了数据结构以及程序的实现细节，这种设计策略称为`信息隐蔽(information hiding)`
* 通常将数据和操纵数据的运算组成`模块(module)`,每个模块有一个明确定义的`接口(interface)`,一个模块的接口是实现运算的一组`函数(functions)`，模块使用封装和信息隐藏原则设计，这样的模块称为`黑盒子(black box)`，模块可以被其它程序或模块调用，它们是该模块的`客户(client)`。
### 1.2.3 数据类型和抽象数据类型
* `数据类型(data type)`定义了一个值的集合以及作用于该值集的运算集合
* `抽象数据类型(Abstract Data Type,ADT)`，数据对象及其运算的规范独立于它们的实现，实行封装和信息隐蔽，使ADT的使用和实现分离
### 1.2.4 数据结构和抽象数据类型
* 逻辑结构和运算的定义组成了数据结构的`规范(specification)`，而数据的存储表示和运算算法的描述构成了数据结构的`实现(implementation)`
## 1.3 描述数据结构
### 1.3.1 数据结构的规范
```c
ADT complex{
    数据：
        由一对实数(x,y)构成，x为实部，y为虚部
    运算：设两个复数分别为a=(a_1,a_2)和b=(b_1,b_2)
        complex create_comp(float x, float y);
        /*构造函数，函数返回复数(x,y)*/
        complex add(complex a, complex b);
        /*设和的实部和虚部分别不超过实型值的允许范围，返回复数(a_1+b_1,a_2+b_2)*/
        complex sub(complex a, complex b);
        /*设差的实部和虚部分别不超过实型值的允许范围，返回复数(a_1-b_1,a_2-b_2)*/
        complex mul(complex a, complex b);
        /*设积的实部和虚部分别不超过实型值的允许范围，返回复数(a_1b_1-a_2b_2,a_1b_1+a_2b_2)*/
        complex div(complex a, complex b);
        /*设除数b不为0，且商的实部和虚部分别不超过实型值的允许范围，返回复数*/
}
```
### 1.3.2 实现数据结构
* 参考文件complex.c
## 算法和算法分析
### 1.4.1 算法及其性能分析
* `算法(algorithm)`是对特定问题求解步骤的一种描述，是指令的有限序列
    1. `输入(input)`：算法有零个或多个输入
    2. `输出(ouput)`：算法至少产生一个输出
    3. `确定性(definite)`：算法的每一条指令都有确切的定义，没有二义性
    4. `能行性(effective)`：算法的每一条指令都足够基本，可以通过有限次已经实现的基本运算来实现
    5. `有穷性(terminative)`：算法总能在执行有限步之后终止
* 衡量算法性能的标准
    1. `正确性(correctness)`：算法的执行结果应该满足预期的功能和性能要求
    2. `简明性(simplicity)`：算法应该思路清晰、层次分明、简单明了、易读易懂
    3. `健壮性(robustness)`：当输入不合法数据时，应当作适当处理
    4. `效率(effeciency)`：有效使用存储空间，并有高的时间效率
### 1.4.2 算法的时间复杂度
* 一个程序的`时间复杂度(time complexity)`是程序运行从开始到结束所需的时间。程序的一次运行是针对所求解问题的某一特定`实例(instance)`而言，实例的`特征(characteristics)`直接影响程序运行的效率。判断算法性能要考虑的一个基本特征是问题实例的`规模(size)`。
* `事前分析(priori analysis)`，排除程序运行环境的因素后讨论算法的时间效率
* `事后测试(posterori testing)`，测试程序在所选择的输入数据下运行时实际需要的时间
* `程序步(program step)`,在语法上或语义上有意义的程序段，执行时间与问题实例的特征无关
### 1.4.3 渐进时间复杂度
* $定义：设f(n)和g(n)是定义在正整数上的正函数，如果存在两个正常数c和n_0，使得当n\ge n_0时，有f(n)\le cg(n)，则记作f(n)=O(g(n))，被记作大O记号(big-Oh\ notation)$
* 大O记号用以表示一个算法运行时间的上界，使用大O记号表示的算法的时间复杂度，称为算法的`渐进时间复杂度(asymptotic complexity)`
* $定理：如果f(n)=a_mn^m+a_{m-1}n^{m-1}+\cdots +a_1n+a_0是m次多项式，则f(n)=O(n^m)$
* $常见渐进时间复杂度排序：O(1)<O(\log_2{n})<O(n)<O(n\log_2{n})<O(n^2)<O(n^3))$
### 1.4.4 最好、最坏和平均时间复杂度
* 最好情况(best case)
* 最坏情况(worst case)
* 平均情况(average case)
### 1.4.5 算法的空间复杂度
* 一个算法的`空间复杂度(space complexity)`是程序运行从开始到结束所需的存储空间
    1. 固定部分(fixed space requirement)：与问题的实例特征无关，主要包括程序代码、常量、简单变量、定长成分的结构变量所占的空间
    2. 可变部分(variable space requirement)：与算法在执行过程中处理的特定数据的大小和规模相关

---------------
# 数组和链表
## 2.1 结构和联合
### 2.1.1 结构
* `结构(structure)`是数据项的`聚集(collection)`
```
struct student
{
    char name[20];
    char sex;
    int age;
};
```
* 结构体备注
  + 允许(编译器支持)将结构作为函数参数传递
  + 同一类型结构，允许进行赋值操作
  + 结构可以作为函数返回值返回
  + 在结构体中使用字符数组或字符指针
    ```c
    struct names
    {
        char first[20];
        char last[20];
    };
    struct pnames
    {
        char *first;
        char *last;
    };
    struct names accountant;
    struct pnames attorney;
    scanf("%s", accountant.last);
    scanf("%S", attorney.last);    /* 存在潜在风险 */
    /*
     * 对于struct names来说，字符串存在结构内部，结构体共分配40个字节存放两个字符串
     * 对于struct pnames来说，结构中存放的是两个地址，共占8个字节，结构不为字符串分配存储空间，适用于管理已创建而且在其它地方已经分配过空间的字符串
     * 上面scanf()会将字符串放到由attoney.last给出的地址中，但该变量未经初始化，该地址可以是任何值，会导致程序彻底停止
     */
    ```
  + 使用malloc来处理字符指针
    ```c
    char temp[81];
    gets(temp);
    panmes.last = (char *)malloc(strlen(temp) + 1);
    strcpy(pnames.last, temp);
    ```
### 2.1.2 联合
* `联合(union)`是在同一个存储空间(不同时)存储不同类型数据的数据类型，定义方法类似结构。
## 2.2 数组
### 2.2.1 一维数组
### 2.2.2 二维数组
* c/c++采用按`行优先顺序(row major order)`存储二维数组元素
* 设有m行n列的二维数组a[m][n]，每个元素占k个存储单元，第一个数组元素a[0][0]的存储地址是Loc(a[0][0])，则数组元素a[i][j]的存储地址Loc(a[i][j])为  
$Loc(a[i][j])=Loc(a[0][0])+(i*n+j)*k\quad(0\le i<m,0\le j<n)$
* Loc(a[0][0])称为`基地址(base address)`,一旦规定了数组的维数和各维长度，便可为其分配存储空间，只要知道数组的下标，就可在O(1)的时间内访问数组内任意元素，称具有这样特点的存储结构为`随机存取的存储结构(random access storage structure)`
### 2.2.3 多维数组
## 2.3 链表
### 2.3.1 指针
* `指针(pointer)`也称为`链(link)`或`引用(reference)`
### 2.3.2 单链表
* `单链表(singly linked list)`的结点由两个域组成：存放元素的域和存放指向后继结点的指针域，第一个结点为`起始结点`，指向起始结点的指针为`头指针`。
* 实现见`singly_linked_list.c`
### 2.3.3 带表头结点的单链表
* 在单链表前增加一个结点，称为`表头结点`，数据域不存放单链表的元素，或者存放辅助信息。
* 实现见`sll_with_header.c`
### 2.3.4 循环链表
* `单循环链表(singly circular linked list)`
### 2.3.5 双向链表
* `双向链表(doubley linked list)`
* 带头结点双向循环链表实现见`dcll.c`

----------------------
# 堆栈和队列
## 3.1 堆栈
### 3.1.1 堆栈ADT
* 堆栈(栈)是限定插入和删除运算只能在同一端进行的线性数据结构。允许插入和删除元素的一端称为`栈顶(top)`，另一端称为'栈底(bottom)'。
```c
ADT Stack
{
    数据:
        零个或多个元素的线性序列(a~0,a~1,···，a~n-1)，其最大允许长度为MaxStack。
    运算：
        void CreateStack(Stack *s, int maxsize);
        /* 构造一个空堆栈 */
        BOOL IsEmpty(Stack s);
        /* 若堆栈为空，则返回TRUE，否则返回FALSE */
        BOOL IsFull(Stack s);
        /* 若堆栈已满，则返回TRUE，否则返回FALSE */
        void Push(Stack *s, T x);
        /* 若堆栈已满，则指示overflow，否则值为x的新元素入栈，成为栈顶元素 */
        void Pop(Stack *s)
        /* 若堆栈已空，则指示underflow，否则栈顶元素从栈中删除 */
        void StackTop(Stack s, T *x);
        /* 若堆栈为空，则指示underflow，否则在参数中返回栈顶元素值 */
}
```
### 3.1.2 堆栈的顺序表示
* 当用一维数组存储栈时，称为`顺序栈(sequential stack)`
    ```c
    #define MaxSize 50
    #define FALSE 0
    #define TRUE  1
    typedef int BOOL;
    typedef int T;
    typedef struct stack
    {
        int top, MaxStack;
        T Elements[MaxSize];
    }Stack;
    ```
### 3.1.3 堆栈的链接表示
* 堆栈在链接存储方式下的实现称为`链式栈(linked stack)`
    ```c
    typedef struct node
    {
        T Element;
        struct node *Link;
    }Node;
    typedef struct stack
    {
        Node *Top;
    }Stack;
    ```
## 3.2 队列
### 3.2.1 队列ADT
* 队列是限定只能在表的一端插入元素，在表的另一端删除元素元素的线性数据结构。允许插入元素的一端称为`队尾(rear)`，允许删除元素的另一端称为`对头(front)`。
    ```c
    Queue
    {
        数据：
            零个或多个元素的线性序列(a_0, a_1, ...,a_n-1),其最大允许长度为MaxQueue
        运算：
            void CreateQueue(Queue *q, int maxsize);
            /* 构造一个空队列 */
            BOOL IsEmpty(Queue q);
            /* 若队列为空，则返回TRUE，否则返回FALSE */
            BOOL IsFull(Queue q);
            /* 若队列已满，则返回TRUE，否则返回FALSE */
            void Append(Queue *q, T x);
            /* 若队列已满，则指示overflow，否则值为x的元素进入队列，成为队尾元素 */
            void Serve(Queue *q);
            /* 若队列为空，则指示underflow，否则从队列中删除对头元素 */
            void QueueFront(Queue q, T *x);
            /* 若队列为空，则指示undeflow，否则参数x中返回对头元素 */
    }
    ```
### 3.2.2 队列的顺序表示
* 用一维数组存储队列时，称为`顺序队列(sequential queue)`
    ```c
    typedef struct queue
    {
        int Front, Rear, MaxQueue;
        T Element[MaxSize];
    }Queue;
    ```
* 循环队列的实现见`seq_circular_queue.c`
### 3.2.3 队列的链接表示
* 链接表示的队列称为`链式队列(linked queue)`
    ```c
    typedef struct queue
    {
        Node *Font, *Rear;
    }Queue;
    ```
## 3.3 表达式的计算
* `表达式计算(expression envaluation)`
### 3.3.1 表达式
* `双目运算符(binary operator)`位于两个操作数之间，如a+b，称为`中缀表达式(infix expression)`
* `单目运算符(unary operator)`，如I++，-a
* `三目运算符(ternary operator)`，条件运算符
* c运算符
  |运算符(优先级从高到低)|结合性|
  |:----------------:|:----|
  |++(后缀) --(后缀) () (调用函数) [] {} (组合文字) . ->|从左到右|
  |++(前缀) --(前缀) - + ~ ！ sizeof * & (type) *`(都是一元运算符)`*|从右到左|
  |(type name)|从右到左|
  |* / % *`(算数运算符)`*|从左到右|
  |+ - *`(二目运算符)`*|从左到右|
  |<< >>|从左到右|
  |< > <= >=|从左到右|
  |== !=|从左到右|
  |&|从左到右|
  |^|从左到右|
  |\||从左到右|
  |&&|从左到右|
  |\|\||从左到右|
  |?:*`(条件表达式)`*|从右到左|
  |= *= /= %= += -= <<= >>= &= \|= ^=|从右到左|
  |,(逗号运算符)|从左到右|

### 3.3.2 中缀表达式转换为后缀表达式
* 编译程序通常需要将中缀表达式转换为相应的后缀表达式才求值。运算符在两个操作数之后的表达式称为`后缀表达式(postfix expression)`，又称`逆波兰表达式(reverse Polish form)`。
* 中缀表达式和后缀表达式
    |中缀表达式|后缀表达式|
    |:------|:--------|
    |a\*b+c|ab\*c+|
    |a\*b/c|ab\*c/|
    |a\*b\*c\*d\*e\*f|ab\*c\*d\*e\*f\*|
    |a+(b\*c+d)/e|abc\*d+e/+|
    |a/(b-c)+d\*e|abc-/de\*+|

* 中缀表达式转化为后缀表达式
    + 先将表达式按优先级顺序用括号括起来
    + 针对运算符，用括号内的运算符取代右括号，最近者优先
    + 将所有左括号去掉即为后缀表达式
    + example
        - a/(b-c)+d*e
        - ((a/(b-c))+(d*e))
        - ((a(bc-/(de*+
        - abc-/de*+
* 转换算法的输入为中缀表达式，该中缀表达式由运算符、操作数、“）”和“#”四种不同类型的项(称为记号，token)组成的序列，左括号的处理归入运算符，表达式以“#”结束。设A是扫描输入中缀表达式时得到的当前项，对A的处理方式为：
   1. 若A为“#”，则输出栈中除栈底“#”外的剩余的运算符，算法终止
   2. 若A为操作数，则将A加到输出序列的尾部
   3. 若A为“）”，则从栈中不断弹出运算符，直至遇到左括号“（”为止。令左括号出栈，A既不进栈，也不输出
   4. 若A是运算符，则将A的优先级与栈顶的运算符作比较，若A的优先级小于等于栈顶的运算符的优先级，则从栈顶弹出运算符，加到输出序列尾部，重复这一操作，直到A的优先级大于栈顶运算符的优先级，令A进栈，结束这一操作  

   |运算符|栈内优先级(isp)|栈外优先级(icp)|
   |:--:|:-----------:|:------------:|
   |-, !|7|7|
   |*, /, %|6|6|
   |+, -|5|5|
   |<, <=, >, >=|4|4|
   |==, !=|3|3|
   |&&|2|2|
   |\|\||1|1|
   |(|0|8|
   |\#|0|0|

* 后缀表达式的计算，从左到右扫描后缀表达式，遇到操作数就进栈，遇到运算符就从栈中弹出两个操作数，执行该运算符规定的运算，并将结果进栈

----------------
# 线性表和数组ADT
## 4.1 线性表
### 4.1.1 线性表ADT
* `线性表(list)`是n(n>=0)个元素a<sub>0</sub>，a<sub>1</sub>，...，a<sub>n-1</sub>的有限序列，记为:(a<sub>0</sub>,a<sub>1</sub>,...,a<sub>n-1</sub>)。其中，n是线性表中元素的个数，即线性表的长度。当n=0时，线性表是空表。
* 设a<sub>i</sub>是第i个元素，称a<sub>i</sub>是a<sub>i+1</sub>的`直接前驱元素(前驱)`，a<sub>i+1</sub>是a<sub>i</sub>的`直接后继元素(后继)`
  ```c
  List
  {
      数据：
          零个或多个元素的线性序列，其最大允许长度为MaxList
      运算：
          void CreateList(List *lst, int maxsize);
          /* 构造一个空线性表 */
          Bool IsEmpty(List lst);
          /* 若线性表为空，则返回TRUE */
          Bool IsFull(List lst);
          /* 若线性表已满，则返回TRUE */
          int Size(List lst);
          /* 返回线性表长度 */
          Bool Insert(List *lst, int pos, T x);
          /* 若线性表未满且0<=pos<=n，则原表中的位置在pos及pos之后的元素后移一位，元素x插在位置pos处，并且函数返回TRUE */
          Bool Remove(List *lst, int pos, T *x);
          /* 若线性表非空且0<=pos<=n，则在位置pos处的元素复制到参数*x，从原表中移去该元素，表中pos之后的所有元素前移一个位置，并且函数返回TRUE */
          Bool Retrieve(List lst, int pos, T *x)
          /* 若线性表非空且0<=pos<=n，则位置pos处的元素复制到参数*x，并且函数返回TRUE */
          Bool Replace(List *lst, int pos, T x);
          /* 若线性表非空且0<=pos<=n，则位置pos处的元素值被x取代，并且函数返回TRUE */
          void Clear(List *lst);
          /* 移去所有元素，线性表称为空表 */
  }
  ```
### 4.1.2 线性表的顺序表示
* 用一维数组存储线性表称为线性表的顺序表示，称为`顺序表`
  |a<sub>0</sub>|a<sub>1</sub>|...|a<sub>pos</sub>|...|a<sub>n-1</sub>||
  |----|---|---|---|----|----|----|
* c语言结构定义
  ```c
  typedef struct list
  {
      int Size, MaxList;
      T Element[MaxSize];
  }List;
  ```
### 4.1.3 线性表的链接表示
* 单链表、循环链表或双向链表存储线性表称为线性表的链接存储表示
### 4.1.4 两种存储方式的比较
* 顺序表可以随机存取，查找指定位置的元素非常方便，但是在插入和删除操作需要移动大量元素，空间需要预先分配，难以临时扩大
* 链式可动态申请结点空间，插入和删除十分容易操作，但是查找前驱需要消耗时间，链接域需要消耗更多的空间
## 4.2 多项式的数据运算
## 4.3 数组作为抽象数据类型
* 数组是`下标(index)`i和`值(value)`v组成的`偶对(pair)`<i,v>的集合
  ```c
  Array
  {
      数据：
          下标i和元素值v的偶对<i,v>的偶对的集合，长度为n。Index是一维或多维的下标的有限有序集合。元素具有T类型。任意两个偶对的下标各不相同。
      运算：
          void CreateArray(Array *A, int n);
          /* 创建长度为n的数组 */
          Bool Retrieve(Array A, Index i, T *x);
          /* 若i \in Index，在参数*x中返回下标为i的元素值，函数返回TRUE */
          Bool Store(Array *A, Index i, T x);
          /* 若i \in Index，将下标为i的元素值置成x，函数返回TRUE */
  }
  ```
## 4.4 特殊矩阵

----------------------------
# 字符串与广义表
## 5.1 字符串
### 5.1.1 字符串ADT
* `字符串(string)`简称为串，是由n(n>=0)个字符组成的有限序列，记为$s="a_0a_1\dots a_{n-1}"$其中，s是串名，双引号括起来的字符序列是串s的值，n是串中字符的个数，又称为串的长度
* n=0的串称为空串。空串不包括任何字符，空白串包括空格符
* 串中任意连续个字符组成的子序列称为该串的`子串(substring)`，包含字串的串称为`主串`
  ```c
  String
  {
    数据：
      零个或多个字符的有限序列，其最大允许长度为MaxString
    运算：
      /* 构建一个空串 */
      void create_string(String *s, int max_size);
      /* 函数值返回字符串s的长度 */
      int length(String s);
      /* 字符串s成为空串 */
      void clear(String *s);
      /* 字符串*s复制串p的值 */
      void copy(String p, String *s);
      /* 若0<=pos<=length(*s)，且length(*s)+length(p)<=max_size，则串*s为在位置pos-1和pos之间插入串p后得到的串，其长度为length(*s)+length(p)，并且函数返回TRUE，否则返回FALSE */
      BOOL insert(String *s, String p, int pos);
      /* 若0<=pos<length(*s)，且length(*s)-pos>=len，则串*s为从位置pos开始删除了长度为len的字串后得到的串，其长度为length(*s)-len，并且函数返回TRUE，否则函数返回FALSE */
      BooL remove(String *s, int pos, int len);
      /*  */
      /* 若0<=pos<length(*s)，且length(*s)-pos>=len，则返回串*s中从位置pos开始，长度为len的字串，否则返回空串 */
      String substring(string s, int pos, int len);
      /* 若0<=pos<length(*s)，则函数值是大于等于pos的最小整数k，使得串p与串s从位置k开始，长度为length(p)的字串相等，并且函数返回k，否则函数返回-1 */
      int index(String s, String p, int pos);
  }
  ```
  ### 5.1.2 字符串的存储表示
  * 串的顺序表示，把串中的字符顺序地存储在一片连续的空间中，C语言以'\0'指示字符串结束
  * 串的链接表示，使用链表存储字符

-----------------------------------
# 树
## 6.1 树的基本概念
### 6.1.1 树的定义
* `树(tree)`是包括$n(n>=1)$个元素的有限非空集合。其中，有一个特定的元素称为`根(root)`，其余元素划分成$m(m>=0)$个互不相交的子集。这$m$个子集每一个也都是树，并称为该树的`子树(subtree)`。

