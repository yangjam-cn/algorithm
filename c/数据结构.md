<!--
 * @Copyright: 《数据结构--C语言描述》陈慧南 编著，《C Primer Plus》
 * @File name: 数据结构.md
 * @Description: 知识点整理和梳理
 * @Author: yangjam
 * @Version: 
 * @Date: 2020-06-12 10:24:50
 * @History: 
    * 6.12 整理数据类型的基本概念
 * @LastEditTime: 2020-06-12 21:59:37
--> 
# 概论
## 1.1 什么是数据结构
### 1.1.1 基本概念
* `数据`：计算机加工处理的对象
    * `数值数据`：整数、实数或复数等
    * `非数值数据`：包括字符、文字、图形、图像、语音等
* `数据元素(data element)`：组成数据的成分数据
* `数据项(data item)`：组成数据元素的成分
* 一个`数据结构(data structure)`是由数据元素依据某种逻辑联系组织起来;对数据元素间的逻辑关系的描述称为数据的`逻辑结构(logic structure)`;数据的`存储结构(storage structure)`是数据结构的实现形式，是在计算机内部的表示;一个数据结构同时也包含在该类数据上执行的`运算(operation)`。
### 1.1.2 数据的逻辑结构
* 大致可分为两类`线性结构(linear structure)`和`非线性结构(non-linear structure)`
    * `集合结构(set)`：元素间的次序是随意的，元素间除了“属于同一个集合”的联系外没有其它联系
    * `线性结构(linear)`：数据元素的有序序列,数据元素间形成一对一关系
    * `树形结构(tree)`：除了一个称为`根`的特殊元素没有前驱(predecesor)只有后继(successor)外，其它元素有且仅有一个前驱，但后继不限。对于非根元素，都存在一条从根到该元素的`路径`。树中元素之间存在一对多的关系。树是层次数据结构。
    * `图状数据(graph)`：数据元素间存在多对多的关系。
### 1.1.3 数据的存储结构
* 两种基本的存储结构，`顺序(sequential)结构`和`链接(linked)结构`
    * 顺序表示方法需要使用一块连续的存储空间，并把逻辑上相关的数据元素依次存储在连续的存储区中
    * 链接表示方法，使用`节点(node)`存储元素本身信息外，还存放与该元素相关的其它元素的位置信息
### 1.1.4 数据结构的运算
* 数据结构常见运算
    1. 创建运算--创建一个数据结构
    2. 清除运算--删除数据结构中的全部元素
    3. 插入运算--在数据结构中插入一个新元素
    4. 删除运算--将数据结构中的某个指定元素删除
    5. 搜索运算--在数据结构中搜索满足一定条件的元素
    6. 更新运算--修改数据结构中某个指定元素的值
    7. 访问运算--访问数据结构中某个元素
    8. 遍历运算--按照某种次序，系统地访问数据结构的各元素
* 若一个数据结构一旦创建，其结构不会发生改变，则称为`静态数据结构(static data structure)`，否则称为`动态数据结构(dynamic data structure)`
## 1.2 数据抽象和抽象数据类型
### 1.2.1 抽象、数据抽象和过程抽象
* `抽象(abstraction)`实质是抽取共同的和本质的内容，忽略非本质的细节
* `数据抽象(data abstraction)`将数据元素间的逻辑关系和数据在计算机内的具体表示分开考虑
* `过程抽象(procedual abstraction)`将运算的定义与实现运算的具体方法分开考虑
### 1.2.2 封装与信息隐藏
* `封装(encapsulation)`是指把数据和操纵数据的运算组合在一起的机制。使用者只通过一组允许的运算访问其中的数据，而不需要了解数据的组织、存储和运算算法如何.封装对使用者隐藏了数据结构以及程序的实现细节，这种设计策略称为`信息隐蔽(information hiding)`
* 通常将数据和操纵数据的运算组成`模块(module)`,每个模块有一个明确定义的`接口(interface)`,一个模块的接口是实现运算的一组`函数(functions)`，模块使用封装和信息隐藏原则设计，这样的模块称为`黑盒子(black box)`，模块可以被其它程序或模块调用，它们是该模块的`客户(client)`。
### 1.2.3 数据类型和抽象数据类型
* `数据类型(data type)`定义了一个值的集合以及作用于该值集的运算集合
* `抽象数据类型(Abstract Data Type,ADT)`，数据对象及其运算的规范独立于它们的实现，实行封装和信息隐蔽，使ADT的使用和实现分离
### 1.2.4 数据结构和抽象数据类型
* 逻辑结构和运算的定义组成了数据结构的`规范(specification)`，而数据的存储表示和运算算法的描述构成了数据结构的`实现(implementation)`
## 1.3 描述数据结构
### 1.3.1 数据结构的规范
```c
ADT complex{
    数据：
        由一对实数(x,y)构成，x为实部，y为虚部
    运算：设两个复数分别为a=(a_1,a_2)和b=(b_1,b_2)
        complex create_comp(float x, float y);
        /*构造函数，函数返回复数(x,y)*/
        complex add(complex a, complex b);
        /*设和的实部和虚部分别不超过实型值的允许范围，返回复数(a_1+b_1,a_2+b_2)*/
        complex sub(complex a, complex b);
        /*设差的实部和虚部分别不超过实型值的允许范围，返回复数(a_1-b_1,a_2-b_2)*/
        complex mul(complex a, complex b);
        /*设积的实部和虚部分别不超过实型值的允许范围，返回复数(a_1b_1-a_2b_2,a_1b_1+a_2b_2)*/
        complex div(complex a, complex b);
        /*设除数b不为0，且商的实部和虚部分别不超过实型值的允许范围，返回复数*/
}
```
### 1.3.2 实现数据结构
* 参考文件complex.c
## 算法和算法分析
### 1.4.1 算法及其性能分析
* `算法(algorithm)`是对特定问题求解步骤的一种描述，是指令的有限序列
    1. `输入(input)`：算法有零个或多个输入
    2. `输出(ouput)`：算法至少产生一个输出
    3. `确定性(definite)`：算法的每一条指令都有确切的定义，没有二义性
    4. `能行性(effective)`：算法的每一条指令都足够基本，可以通过有限次已经实现的基本运算来实现
    5. `有穷性(terminative)`：算法总能在执行有限步之后终止
* 衡量算法性能的标准
    1. `正确性(correctness)`：算法的执行结果应该满足预期的功能和性能要求
    2. `简明性(simplicity)`：算法应该思路清晰、层次分明、简单明了、易读易懂
    3. `健壮性(robustness)`：当输入不合法数据时，应当作适当处理
    4. `效率(effeciency)`：有效使用存储空间，并有高的时间效率
### 1.4.2 算法的时间复杂度
* 一个程序的`时间复杂度(time complexity)`是程序运行从开始到结束所需的时间。程序的一次运行是针对所求解问题的某一特定`实例(instance)`而言，实例的`特征(characteristics)`直接影响程序运行的效率。判断算法性能要考虑的一个基本特征是问题实例的`规模(size)`。
* `事前分析(priori analysis)`，排除程序运行环境的因素后讨论算法的时间效率
* `事后测试(posterori testing)`，测试程序在所选择的输入数据下运行时实际需要的时间
* `程序步(program step)`,在语法上或语义上有意义的程序段，执行时间与问题实例的特征无关
### 1.4.3 渐进时间复杂度
* $定义：设f(n)和g(n)是定义在正整数上的正函数，如果存在两个正常数c和n_0，使得当n\ge n_0时，有f(n)\le cg(n)，则记作f(n)=O(g(n))，被记作大O记号(big-Oh\ notation)$
* 大O记号用以表示一个算法运行时间的上界，使用大O记号表示的算法的时间复杂度，称为算法的`渐进时间复杂度(asymptotic complexity)`
* $定理：如果f(n)=a_mn^m+a_{m-1}n^{m-1}+\cdots +a_1n+a_0是m次多项式，则f(n)=O(n^m)$
* $常见渐进时间复杂度排序：O(1)<O(\log_2{n})<O(n)<O(n\log_2{n})<O(n^2)<O(n^3))$
### 1.4.4 最好、最坏和平均时间复杂度
* 最好情况(best case)
* 最坏情况(worst case)
* 平均情况(average case)
### 1.4.5 算法的空间复杂度
* 一个算法的`空间复杂度(space complexity)`是程序运行从开始到结束所需的存储空间
    1. 固定部分(fixed space requirement)：与问题的实例特征无关，主要包括程序代码、常量、简单变量、定长成分的结构变量所占的空间
    2. 可变部分(variable space requirement)：与算法在执行过程中处理的特定数据的大小和规模相关
# 数组和链表
## 2.1 结构和联合
### 2.1.1 结构
* `结构(structure)`是数据项的`聚集(collection)`
```
struct student
{
    char name[20];
    char sex;
    int age;
};
```
* 结构体备注
  + 允许(编译器支持)将结构作为函数参数传递
  + 同一类型结构，允许进行赋值操作
  + 结构可以作为函数返回值返回
  + 在结构体中使用字符数组或字符指针
    ```c
    struct names
    {
        char first[20];
        char last[20];
    };
    struct pnames
    {
        char *first;
        char *last;
    };
    struct names accountant;
    struct pnames attorney;
    scanf("%s", accountant.last);
    scanf("%S", attorney.last);    /* 存在潜在风险 */
    /*
     * 对于struct names来说，字符串存在结构内部，结构体共分配40个字节存放两个字符串
     * 对于struct pnames来说，结构中存放的是两个地址，共占8个字节，结构不为字符串分配存储空间，适用于管理已创建而且在其它地方已经分配过空间的字符串
     * 上面scanf()会将字符串放到由attoney.last给出的地址中，但该变量未经初始化，该地址可以是任何值，会导致程序彻底停止
     */
    ```
  + 使用malloc来处理字符指针
    ```c
    char temp[81];
    gets(temp);
    panmes.last = (char *)malloc(strlen(temp) + 1);
    strcpy(pnames.last, temp);
    ```
### 2.1.2 联合
* `联合(union)`是在同一个存储空间(不同时)存储不同类型数据的数据类型，定义方法类似结构。