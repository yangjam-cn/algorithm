<!--
 * @Copyright: 《数据结构--C语言描述》陈慧南 编著，《C Primer Plus》
 * @File name: 数据结构.md
 * @Description: 知识点整理和梳理
 * @Author: yangjam
 * @Version: 
 * @Date: 2020-06-12 10:24:50
 * @History: 
    * 6.12 整理数据类型的基本概念
 * @LastEditTime: 2020-06-18 13:45:12
--> 
# 概论
## 1.1 什么是数据结构
### 1.1.1 基本概念
* `数据`：计算机加工处理的对象
    * `数值数据`：整数、实数或复数等
    * `非数值数据`：包括字符、文字、图形、图像、语音等
* `数据元素(data element)`：组成数据的成分数据
* `数据项(data item)`：组成数据元素的成分
* 一个`数据结构(data structure)`是由数据元素依据某种逻辑联系组织起来;对数据元素间的逻辑关系的描述称为数据的`逻辑结构(logic structure)`;数据的`存储结构(storage structure)`是数据结构的实现形式，是在计算机内部的表示;一个数据结构同时也包含在该类数据上执行的`运算(operation)`。
### 1.1.2 数据的逻辑结构
* 大致可分为两类`线性结构(linear structure)`和`非线性结构(non-linear structure)`
    * `集合结构(set)`：元素间的次序是随意的，元素间除了“属于同一个集合”的联系外没有其它联系
    * `线性结构(linear)`：数据元素的有序序列,数据元素间形成一对一关系
    * `树形结构(tree)`：除了一个称为`根`的特殊元素没有前驱(predecesor)只有后继(successor)外，其它元素有且仅有一个前驱，但后继不限。对于非根元素，都存在一条从根到该元素的`路径`。树中元素之间存在一对多的关系。树是层次数据结构。
    * `图状数据(graph)`：数据元素间存在多对多的关系。
### 1.1.3 数据的存储结构
* 两种基本的存储结构，`顺序(sequential)结构`和`链接(linked)结构`
    * 顺序表示方法需要使用一块连续的存储空间，并把逻辑上相关的数据元素依次存储在连续的存储区中
    * 链接表示方法，使用`节点(node)`存储元素本身信息外，还存放与该元素相关的其它元素的位置信息
### 1.1.4 数据结构的运算
* 数据结构常见运算
    1. 创建运算--创建一个数据结构
    2. 清除运算--删除数据结构中的全部元素
    3. 插入运算--在数据结构中插入一个新元素
    4. 删除运算--将数据结构中的某个指定元素删除
    5. 搜索运算--在数据结构中搜索满足一定条件的元素
    6. 更新运算--修改数据结构中某个指定元素的值
    7. 访问运算--访问数据结构中某个元素
    8. 遍历运算--按照某种次序，系统地访问数据结构的各元素
* 若一个数据结构一旦创建，其结构不会发生改变，则称为`静态数据结构(static data structure)`，否则称为`动态数据结构(dynamic data structure)`
## 1.2 数据抽象和抽象数据类型
### 1.2.1 抽象、数据抽象和过程抽象
* `抽象(abstraction)`实质是抽取共同的和本质的内容，忽略非本质的细节
* `数据抽象(data abstraction)`将数据元素间的逻辑关系和数据在计算机内的具体表示分开考虑
* `过程抽象(procedual abstraction)`将运算的定义与实现运算的具体方法分开考虑
### 1.2.2 封装与信息隐藏
* `封装(encapsulation)`是指把数据和操纵数据的运算组合在一起的机制。使用者只通过一组允许的运算访问其中的数据，而不需要了解数据的组织、存储和运算算法如何.封装对使用者隐藏了数据结构以及程序的实现细节，这种设计策略称为`信息隐蔽(information hiding)`
* 通常将数据和操纵数据的运算组成`模块(module)`,每个模块有一个明确定义的`接口(interface)`,一个模块的接口是实现运算的一组`函数(functions)`，模块使用封装和信息隐藏原则设计，这样的模块称为`黑盒子(black box)`，模块可以被其它程序或模块调用，它们是该模块的`客户(client)`。
### 1.2.3 数据类型和抽象数据类型
* `数据类型(data type)`定义了一个值的集合以及作用于该值集的运算集合
* `抽象数据类型(Abstract Data Type,ADT)`，数据对象及其运算的规范独立于它们的实现，实行封装和信息隐蔽，使ADT的使用和实现分离
### 1.2.4 数据结构和抽象数据类型
* 逻辑结构和运算的定义组成了数据结构的`规范(specification)`，而数据的存储表示和运算算法的描述构成了数据结构的`实现(implementation)`
## 1.3 描述数据结构
### 1.3.1 数据结构的规范
```c
ADT complex{
    数据：
        由一对实数(x,y)构成，x为实部，y为虚部
    运算：设两个复数分别为a=(a_1,a_2)和b=(b_1,b_2)
        complex create_comp(float x, float y);
        /*构造函数，函数返回复数(x,y)*/
        complex add(complex a, complex b);
        /*设和的实部和虚部分别不超过实型值的允许范围，返回复数(a_1+b_1,a_2+b_2)*/
        complex sub(complex a, complex b);
        /*设差的实部和虚部分别不超过实型值的允许范围，返回复数(a_1-b_1,a_2-b_2)*/
        complex mul(complex a, complex b);
        /*设积的实部和虚部分别不超过实型值的允许范围，返回复数(a_1b_1-a_2b_2,a_1b_1+a_2b_2)*/
        complex div(complex a, complex b);
        /*设除数b不为0，且商的实部和虚部分别不超过实型值的允许范围，返回复数*/
}
```
### 1.3.2 实现数据结构
* 参考文件complex.c
## 算法和算法分析
### 1.4.1 算法及其性能分析
* `算法(algorithm)`是对特定问题求解步骤的一种描述，是指令的有限序列
    1. `输入(input)`：算法有零个或多个输入
    2. `输出(ouput)`：算法至少产生一个输出
    3. `确定性(definite)`：算法的每一条指令都有确切的定义，没有二义性
    4. `能行性(effective)`：算法的每一条指令都足够基本，可以通过有限次已经实现的基本运算来实现
    5. `有穷性(terminative)`：算法总能在执行有限步之后终止
* 衡量算法性能的标准
    1. `正确性(correctness)`：算法的执行结果应该满足预期的功能和性能要求
    2. `简明性(simplicity)`：算法应该思路清晰、层次分明、简单明了、易读易懂
    3. `健壮性(robustness)`：当输入不合法数据时，应当作适当处理
    4. `效率(effeciency)`：有效使用存储空间，并有高的时间效率
### 1.4.2 算法的时间复杂度
* 一个程序的`时间复杂度(time complexity)`是程序运行从开始到结束所需的时间。程序的一次运行是针对所求解问题的某一特定`实例(instance)`而言，实例的`特征(characteristics)`直接影响程序运行的效率。判断算法性能要考虑的一个基本特征是问题实例的`规模(size)`。
* `事前分析(priori analysis)`，排除程序运行环境的因素后讨论算法的时间效率
* `事后测试(posterori testing)`，测试程序在所选择的输入数据下运行时实际需要的时间
* `程序步(program step)`,在语法上或语义上有意义的程序段，执行时间与问题实例的特征无关
### 1.4.3 渐进时间复杂度
* $定义：设f(n)和g(n)是定义在正整数上的正函数，如果存在两个正常数c和n_0，使得当n\ge n_0时，有f(n)\le cg(n)，则记作f(n)=O(g(n))，被记作大O记号(big-Oh\ notation)$
* 大O记号用以表示一个算法运行时间的上界，使用大O记号表示的算法的时间复杂度，称为算法的`渐进时间复杂度(asymptotic complexity)`
* $定理：如果f(n)=a_mn^m+a_{m-1}n^{m-1}+\cdots +a_1n+a_0是m次多项式，则f(n)=O(n^m)$
* $常见渐进时间复杂度排序：O(1)<O(\log_2{n})<O(n)<O(n\log_2{n})<O(n^2)<O(n^3))$
### 1.4.4 最好、最坏和平均时间复杂度
* 最好情况(best case)
* 最坏情况(worst case)
* 平均情况(average case)
### 1.4.5 算法的空间复杂度
* 一个算法的`空间复杂度(space complexity)`是程序运行从开始到结束所需的存储空间
    1. 固定部分(fixed space requirement)：与问题的实例特征无关，主要包括程序代码、常量、简单变量、定长成分的结构变量所占的空间
    2. 可变部分(variable space requirement)：与算法在执行过程中处理的特定数据的大小和规模相关
***
# 数组和链表
## 2.1 结构和联合
### 2.1.1 结构
* `结构(structure)`是数据项的`聚集(collection)`
```
struct student
{
    char name[20];
    char sex;
    int age;
};
```
* 结构体备注
  + 允许(编译器支持)将结构作为函数参数传递
  + 同一类型结构，允许进行赋值操作
  + 结构可以作为函数返回值返回
  + 在结构体中使用字符数组或字符指针
    ```c
    struct names
    {
        char first[20];
        char last[20];
    };
    struct pnames
    {
        char *first;
        char *last;
    };
    struct names accountant;
    struct pnames attorney;
    scanf("%s", accountant.last);
    scanf("%S", attorney.last);    /* 存在潜在风险 */
    /*
     * 对于struct names来说，字符串存在结构内部，结构体共分配40个字节存放两个字符串
     * 对于struct pnames来说，结构中存放的是两个地址，共占8个字节，结构不为字符串分配存储空间，适用于管理已创建而且在其它地方已经分配过空间的字符串
     * 上面scanf()会将字符串放到由attoney.last给出的地址中，但该变量未经初始化，该地址可以是任何值，会导致程序彻底停止
     */
    ```
  + 使用malloc来处理字符指针
    ```c
    char temp[81];
    gets(temp);
    panmes.last = (char *)malloc(strlen(temp) + 1);
    strcpy(pnames.last, temp);
    ```
### 2.1.2 联合
* `联合(union)`是在同一个存储空间(不同时)存储不同类型数据的数据类型，定义方法类似结构。
## 2.2 数组
### 2.2.1 一维数组
### 2.2.2 二维数组
* c/c++采用按`行优先顺序(row major order)`存储二维数组元素
* 设有m行n列的二维数组a[m][n]，每个元素占k个存储单元，第一个数组元素a[0][0]的存储地址是Loc(a[0][0])，则数组元素a[i][j]的存储地址Loc(a[i][j])为  
$Loc(a[i][j])=Loc(a[0][0])+(i*n+j)*k\quad(0\le i<m,0\le j<n)$
* Loc(a[0][0])称为`基地址(base address)`,一旦规定了数组的维数和各维长度，便可为其分配存储空间，只要知道数组的下标，就可在O(1)的时间内访问数组内任意元素，称具有这样特点的存储结构为`随机存取的存储结构(random access storage structure)`
### 2.2.3 多维数组
## 2.3 链表
### 2.3.1 指针
* `指针(pointer)`也称为`链(link)`或`引用(reference)`
### 2.3.2 单链表
* `单链表(singly linked list)`的结点由两个域组成：存放元素的域和存放指向后继结点的指针域，第一个结点为`起始结点`，指向起始结点的指针为`头指针`。
* 实现见`singly_linked_list.c`
### 2.3.3 带表头结点的单链表
* 在单链表前增加一个结点，称为`表头结点`，数据域不存放单链表的元素，或者存放辅助信息。
* 实现见`sll_with_header.c`
### 2.3.4 循环链表
* `单循环链表(singly circular linked list)`
### 2.3.5 双向链表
* `双向链表(doubley linked list)`
* 带头结点双向循环链表实现见`dcll.c`
******
# 堆栈和队列
## 3.1 堆栈
### 3.1.1 堆栈ADT
* 堆栈(栈)是限定插入和删除运算只能在同一端进行的线性数据结构。允许插入和删除元素的一端称为`栈顶(top)`，另一端称为'栈底(bottom)'。
```c
ADT Stack
{
    数据:
        零个或多个元素的线性序列(a~0,a~1,···，a~n-1)，其最大允许长度为MaxStack。
    运算：
        void CreateStack(Stack *s, int maxsize);
        /* 构造一个空堆栈 */
        BOOL IsEmpty(Stack s);
        /* 若堆栈为空，则返回TRUE，否则返回FALSE */
        BOOL IsFull(Stack s);
        /* 若堆栈已满，则返回TRUE，否则返回FALSE */
        void Push(Stack *s, T x);
        /* 若堆栈已满，则指示overflow，否则值为x的新元素入栈，成为栈顶元素 */
        void Pop(Stack *s)
        /* 若堆栈已空，则指示underflow，否则栈顶元素从栈中删除 */
        void StackTop(Stack s, T *x);
        /* 若堆栈为空，则指示underflow，否则在参数中返回栈顶元素值 */
}
```
### 3.1.2 堆栈的顺序表示
* 当用一维数组存储栈时，称为`顺序栈(sequential stack)`
    ```c
    #define MaxSize 50
    #define FALSE 0
    #define TRUE  1
    typedef int BOOL;
    typedef int T;
    typedef struct stack
    {
        int top, MaxStack;
        T Elements[MaxSize];
    }Stack;
    ```
### 3.1.3 堆栈的链接表示
* 堆栈在链接存储方式下的实现称为`链式栈(linked stack)`
    ```c
    typedef struct node
    {
        T Element;
        struct node *Link;
    }Node;
    typedef struct stack
    {
        Node *Top;
    }Stack;
    ```
## 3.2 队列
### 3.2.1 队列ADT
* 队列是限定只能在表的一端插入元素，在表的另一端删除元素元素的线性数据结构。允许插入元素的一端称为`队尾(rear)`，允许删除元素的另一端称为`对头(front)`。
    ```c
    Queue
    {
        数据：
            零个或多个元素的线性序列(a_0, a_1, ...,a_n-1),其最大允许长度为MaxQueue
        运算：
            void CreateQueue(Queue *q, int maxsize);
            /* 构造一个空队列 */
            BOOL IsEmpty(Queue q);
            /* 若队列为空，则返回TRUE，否则返回FALSE */
            BOOL IsFull(Queue q);
            /* 若队列已满，则返回TRUE，否则返回FALSE */
            void Append(Queue *q, T x);
            /* 若队列已满，则指示overflow，否则值为x的元素进入队列，成为队尾元素 */
            void Serve(Queue *q);
            /* 若队列为空，则指示underflow，否则从队列中删除对头元素 */
            void QueueFront(Queue q, T *x);
            /* 若队列为空，则指示undeflow，否则参数x中返回对头元素 */
    }
    ```
### 3.2.2 队列的顺序表示
* 用一维数组存储队列时，称为`顺序队列(sequential queue)`
    ```c
    typedef struct queue
    {
        int Front, Rear, MaxQueue;
        T Element[MaxSize];
    }Queue;
    ```
* 循环队列的实现见`seq_circular_queue.c`
### 3.2.3 队列的链接表示
* 链接表示的队列称为`链式队列(linked queue)`
    ```c
    typedef struct queue
    {
        Node *Font, *Rear;
    }Queue;
    ```
## 3.3 表达式的计算
* `表达式计算(expression envaluation)`
### 3.3.1 表达式
* `双目运算符(binary operator)`位于两个操作数之间，如a+b，称为`中缀表达式(infix expression)`
* `单目运算符(unary operator)`，如I++，-a
* `三目运算符(ternary operator)`，条件运算符
* c运算符
  |运算符(优先级从高到低)|结合性|
  |:----------------:|:----|
  |++(后缀) --(后缀) () (调用函数) [] {} (组合文字) . ->|从左到右|
  |++(前缀) --(前缀) - + ~ ！ sizeof * & (type) *`(都是一元运算符)`*|从右到左|
  |(type name)|从右到左|
  |* / % *`(算数运算符)`*|从左到右|
  |+ - *`(二目运算符)`*|从左到右|
  |<< >>|从左到右|
  |< > <= >=|从左到右|
  |== !=|从左到右|
  |&|从左到右|
  |^|从左到右|
  |\||从左到右|
  |&&|从左到右|
  |\|\||从左到右|
  |?:*`(条件表达式)`*|从右到左|
  |= *= /= %= += -= <<= >>= &= \|= ^=|从右到左|
  |,(逗号运算符)|从左到右|
### 3.3.3 中缀表达式转换为后缀表达式
* 编译程序通常需要将中缀表达式转换为相应的后缀表达式才求值。运算符在两个操作数之后的表达式称为`后缀表达式(postfix expression)`，又称`逆波兰表达式(reverse Polish form)`。
* 中缀表达式和后缀表达式
    |中缀表达式|后缀表达式|
    |:------|:--------|
    |a\*b+c|ab\*c+|
    |a\*b/c|ab\*c/|
    |a\*b\*c\*d\*e\*f|ab\*c\*d\*e\*f\*|
    |a+(b\*c+d)/e|abc\*d+e/+|
    |a/(b-c)+d\*e|abc-/de\*+|
* 中缀表达式转化为后缀表达式
    + 先将表达式按优先级顺序用括号括起来
    + 针对运算符，用括号内的运算符取代右括号，最近者优先
    + 将所有左括号去掉即为后缀表达式
    + example
        - a/(b-c)+d*e
        - ((a/(b-c))+(d*e))
        - ((a(bc-/(de*+
        - abc-/de*+
* 转换算法的输入为中缀表达式，该中缀表达式由运算符、操作数、“）”和“#”四种不同类型的项(称为记号，token)组成的序列，左括号的处理归入运算符，表达式以“#”结束。设A是扫描输入中缀表达式时得到的当前项，对A的处理方式为：
   1. 若A为“#”，则输出栈中除栈底“#”外的剩余的运算符，算法终止
   2. 若A为操作数，则将A加到输出序列的尾部
   3. 若A为“）”，则从栈中不断弹出运算符，直至遇到左括号“（”为止。令左括号出栈，A既不进栈，也不输出
   4. 若A是运算符，则将A的优先级与栈顶的运算符作比较，若A的优先级小于等于栈顶的运算符的优先级，则从栈顶弹出运算符，加到输出序列尾部，重复这一操作，直到A的优先级大于栈顶运算符的优先级，令A进栈，结束这一操作  

   |运算符|栈内优先级(isp)|栈外优先级(icp)|
   |:--:|:-----------:|:------------:|
   |-, !|7|7|
   |*, /, %|6|6|
   |+, -|5|5|
   |<, <=, >, >=|4|4|
   |==, !=|3|3|
   |&&|2|2|
   |\|\||1|1|
   |(|0|8|
   |#|0|0|
* 后缀表达式的计算，从左到右扫描后缀表达式，遇到操作数就进栈，遇到运算符就从栈中弹出两个操作数，执行该运算符规定的运算，并将结果进栈